/**
 * @license
 * Copyright 2025 AionUi (aionui.com)
 * SPDX-License-Identifier: Apache-2.0
 */

import './utils/configureChromium';
import { app, BrowserWindow, Menu, Tray, dialog, screen, shell } from 'electron';
import fixPath from 'fix-path';
import * as fs from 'fs';
import * as path from 'path';
import { networkInterfaces } from 'os';
import { initMainAdapterWithWindow } from './adapter/main';
import { ipcBridge } from './common';
import { initializeProcess } from './process';
import { initializeAcpDetector } from './process/bridge';
import { registerWindowMaximizeListeners } from './process/bridge/windowControlsBridge';
import WorkerManage from './process/WorkerManage';
import { setupApplicationMenu } from './utils/appMenu';
import { startWebServer } from './webserver';
import { SERVER_CONFIG } from './webserver/config/constants';
import { applyZoomToWindow } from './process/utils/zoom';
import { ConfigStorage } from './common/storage';
import { applyStartupSettingsToSystem, wasLaunchedAtLogin, type StartupSettings } from './process/utils/autoStart';
import { getCloseToTray, setCloseToTray } from './process/runtime/appRuntimeSettings';
import { getTrayIcon, getTrayIconSyncFallback } from './process/utils/trayIcon';
import { getSystemMainLocale, loadMainLocale, tMain, type MainLocale } from './process/utils/mainI18n';
// @ts-expect-error - electron-squirrel-startup doesn't have types
import electronSquirrelStartup from 'electron-squirrel-startup';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// 修复 macOS 和 Linux 下 GUI 应用的 PATH 环境变量,使其与命令行一致
if (process.platform === 'darwin' || process.platform === 'linux') {
  fixPath();
}

// Handle Squirrel startup events (Windows installer)
if (electronSquirrelStartup) {
  app.quit();
}

// 主进程全局错误处理器
// Global error handlers for main process
// 捕获未处理的同步异常，防止显示 Electron 默认错误对话框
// Catch uncaught synchronous exceptions to prevent Electron's default error dialog
process.on('uncaughtException', (_error) => {
  // 在生产环境中，可以将错误记录到文件或上报到错误追踪服务
  // In production, errors can be logged to file or sent to error tracking service
  if (process.env.NODE_ENV !== 'development') {
    // TODO: Add error logging or reporting
  }
});

// 捕获未处理的 Promise 拒绝，避免应用崩溃
// Catch unhandled Promise rejections to prevent app crashes
process.on('unhandledRejection', (_reason, _promise) => {
  // 可以在这里添加错误上报逻辑
  // Error reporting logic can be added here
});

const hasSwitch = (flag: string) => process.argv.includes(`--${flag}`) || app.commandLine.hasSwitch(flag);
const getSwitchValue = (flag: string): string | undefined => {
  const withEqualsPrefix = `--${flag}=`;
  const equalsArg = process.argv.find((arg) => arg.startsWith(withEqualsPrefix));
  if (equalsArg) {
    return equalsArg.slice(withEqualsPrefix.length);
  }

  const argIndex = process.argv.indexOf(`--${flag}`);
  if (argIndex !== -1) {
    const nextArg = process.argv[argIndex + 1];
    if (nextArg && !nextArg.startsWith('--')) {
      return nextArg;
    }
  }

  const cliValue = app.commandLine.getSwitchValue(flag);
  return cliValue || undefined;
};
const hasCommand = (cmd: string) => process.argv.includes(cmd);

const WEBUI_CONFIG_FILE = 'webui.config.json';

type WebUIUserConfig = {
  port?: number | string;
  allowRemote?: boolean;
};

const parsePortValue = (value: unknown, _sourceLabel: string): number | null => {
  if (value === undefined || value === null || value === '') {
    return null;
  }

  const portNumber = typeof value === 'number' ? value : parseInt(String(value), 10);
  if (!Number.isFinite(portNumber) || portNumber < 1 || portNumber > 65535) {
    return null;
  }
  return portNumber;
};

const loadUserWebUIConfig = (): { config: WebUIUserConfig; path: string | null; exists: boolean } => {
  try {
    const userDataPath = app.getPath('userData');
    const configPath = path.join(userDataPath, WEBUI_CONFIG_FILE);
    if (!fs.existsSync(configPath)) {
      return { config: {}, path: configPath, exists: false };
    }

    const raw = fs.readFileSync(configPath, 'utf-8');
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') {
      return { config: {}, path: configPath, exists: false };
    }
    return { config: parsed as WebUIUserConfig, path: configPath, exists: true };
  } catch (error) {
    return { config: {}, path: null, exists: false };
  }
};

const resolveWebUIPort = (config: WebUIUserConfig): number => {
  const cliPort = parsePortValue(getSwitchValue('port') ?? getSwitchValue('webui-port'), 'CLI (--port)');
  if (cliPort) return cliPort;

  const envPort = parsePortValue(process.env.AIONUI_PORT ?? process.env.PORT, 'environment variable (AIONUI_PORT/PORT)');
  if (envPort) return envPort;

  const configPort = parsePortValue(config.port, 'webui.config.json');
  if (configPort) return configPort;

  return SERVER_CONFIG.DEFAULT_PORT;
};

const parseBooleanEnv = (value?: string): boolean | null => {
  if (!value) return null;
  const normalized = value.trim().toLowerCase();
  if (['1', 'true', 'yes', 'on'].includes(normalized)) return true;
  if (['0', 'false', 'no', 'off'].includes(normalized)) return false;
  return null;
};

const resolveRemoteAccess = (config: WebUIUserConfig): boolean => {
  const envRemote = parseBooleanEnv(process.env.AIONUI_ALLOW_REMOTE || process.env.AIONUI_REMOTE);
  const hostHint = process.env.AIONUI_HOST?.trim();
  const hostRequestsRemote = hostHint ? ['0.0.0.0', '::', '::0'].includes(hostHint) : false;
  const configRemote = config.allowRemote === true;

  return isRemoteMode || hostRequestsRemote || envRemote === true || configRemote;
};

const isWebUIMode = hasSwitch('webui');
const isRemoteMode = hasSwitch('remote');
const isResetPasswordMode = hasCommand('--resetpass');

let mainWindow: BrowserWindow;
let tray: Tray | null = null;
let isAppQuitting = false;

let mainLocale: MainLocale = 'en-US';

let webUiServiceStarted = false;
let webUiServiceInfo: { port: number; allowRemote: boolean } | null = null;

const isLinuxHeadless = process.platform === 'linux' && !process.env.DISPLAY && !process.env.WAYLAND_DISPLAY;

const getLanIP = (): string | null => {
  const nets = networkInterfaces();
  for (const name of Object.keys(nets)) {
    const netInfo = nets[name];
    if (!netInfo) continue;
    for (const net of netInfo) {
      const isIPv4 = net.family === 'IPv4';
      const isNotInternal = !net.internal;
      if (isIPv4 && isNotInternal) {
        return net.address;
      }
    }
  }
  return null;
};

const getWebUiUrlForOpen = (port: number, allowRemote: boolean): string => {
  const localUrl = `http://localhost:${port}`;
  if (!allowRemote) return localUrl;

  const lanIP = getLanIP();
  return lanIP ? `http://${lanIP}:${port}` : localUrl;
};

const showMainWindow = (): void => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.show();
    mainWindow.focus();
    return;
  }
  createWindow();
};

const buildTrayContextMenu = () => {
  return Menu.buildFromTemplate([
    {
      label: tMain(mainLocale, 'tray.openWebUi'),
      click: () => {
        void handleTrayOpenWebUi();
      },
    },
    {
      label: tMain(mainLocale, 'tray.openMain'),
      click: () => {
        showMainWindow();
      },
    },
    { type: 'separator' },
    {
      label: tMain(mainLocale, 'tray.quit'),
      click: () => {
        isAppQuitting = true;
        app.quit();
      },
    },
  ]);
};

const refreshTrayUi = () => {
  if (!tray) return;
  tray.setToolTip(tMain(mainLocale, 'tray.tooltip'));
  tray.setContextMenu(buildTrayContextMenu());
};

const ensureTray = (): void => {
  if (tray || isLinuxHeadless) return;

  // Create immediately with a synchronous fallback icon to avoid blocking startup.
  tray = new Tray(getTrayIconSyncFallback());
  refreshTrayUi();

  // Upgrade icon asynchronously if we can fetch a better one.
  // (Currently getTrayIcon is synchronous; keep this pattern if we reintroduce async later.)
  const img = getTrayIcon();
  if (tray && !img.isEmpty()) {
    tray.setImage(img);
  }

  tray.on('double-click', () => {
    showMainWindow();
  });
};

const handleTrayOpenWebUi = async (): Promise<void> => {
  const userConfigInfo = loadUserWebUIConfig();
  const resolvedPort = resolveWebUIPort(userConfigInfo.config);
  const allowRemote = resolveRemoteAccess(userConfigInfo.config);

  try {
    if (!webUiServiceStarted) {
      await startWebServer(resolvedPort, allowRemote, { openBrowser: true });
      webUiServiceStarted = true;
      webUiServiceInfo = { port: resolvedPort, allowRemote };
      return;
    }

    const info = webUiServiceInfo ?? { port: resolvedPort, allowRemote };
    void shell.openExternal(getWebUiUrlForOpen(info.port, info.allowRemote));
  } catch (error) {
    const errno = error as NodeJS.ErrnoException;
    const isPortInUse = errno?.code === 'EADDRINUSE';
    const message = isPortInUse ? `${tMain(mainLocale, 'webui.dialog.portInUse', { port: resolvedPort })}\n\n${tMain(mainLocale, 'webui.dialog.portInUseHint')}` : `${tMain(mainLocale, 'webui.dialog.startFailed')}\n\n${errno?.message ?? String(error)}`;

    await dialog.showMessageBox({
      type: 'error',
      title: tMain(mainLocale, 'webui.dialog.title'),
      message,
    });
  }
};

const createWindow = (): void => {
  // Get primary display size
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;

  // Set window size to 80% (4/5) of screen size for better visibility on high-resolution displays
  const windowWidth = Math.floor(screenWidth * 0.8);
  const windowHeight = Math.floor(screenHeight * 0.8);

  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: windowWidth,
    height: windowHeight,
    autoHideMenuBar: true,
    // Custom titlebar configuration / 自定义标题栏配置
    ...(process.platform === 'darwin'
      ? {
          titleBarStyle: 'hidden',
          trafficLightPosition: { x: 10, y: 10 },
        }
      : { frame: false }),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      webviewTag: true, // 启用 webview 标签用于 HTML 预览 / Enable webview tag for HTML preview
    },
  });

  mainWindow.on('close', (event) => {
    // If user wants close-to-tray and tray exists, hide instead of quitting.
    if (isAppQuitting) return;
    if (tray && getCloseToTray()) {
      event.preventDefault();
      mainWindow.hide();
    }
  });

  initMainAdapterWithWindow(mainWindow);
  setupApplicationMenu();
  void applyZoomToWindow(mainWindow);
  registerWindowMaximizeListeners(mainWindow);

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch((_error) => {
    // Error loading main window URL
  });

  // 只在开发环境自动打开 DevTools / Only auto-open DevTools in development
  // 使用 app.isPackaged 判断更可靠，打包后的应用不会自动打开 DevTools
  // Using app.isPackaged is more reliable, packaged apps won't auto-open DevTools
  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools();
  }
};

// Menu.setApplicationMenu(null);

ipcBridge.application.openDevTools.provider(() => {
  if (mainWindow) {
    mainWindow.webContents.openDevTools();
  }
  return Promise.resolve();
});

const handleAppReady = async (): Promise<void> => {
  try {
    await initializeProcess();
  } catch (error) {
    console.error('Failed to initialize process:', error);
    app.exit(1);
    return;
  }

  // Avoid blocking app startup on storage/i18n; start with system locale then refresh.
  mainLocale = getSystemMainLocale();
  void loadMainLocale().then((locale) => {
    mainLocale = locale;
    refreshTrayUi();
  });

  const startupSettings: StartupSettings = {
    startOnBoot: (await ConfigStorage.get('app.startOnBoot').catch(() => false)) === true,
    openWebUiOnBoot: (await ConfigStorage.get('app.openWebUiOnBoot').catch(() => false)) === true,
    silentOnBoot: (await ConfigStorage.get('app.silentOnBoot').catch(() => false)) === true,
    closeToTray: (await ConfigStorage.get('app.closeToTray').catch(() => true)) !== false,
  };

  // Apply runtime close behavior immediately.
  setCloseToTray(startupSettings.closeToTray);

  // Keep OS login-item registration in sync with stored settings.
  // Failures here should not prevent the app from launching.
  try {
    await applyStartupSettingsToSystem(startupSettings);
  } catch (error) {
    console.warn('[AionUi] Failed to apply startup settings:', error);
  }

  const isBootAutoStart = startupSettings.startOnBoot && wasLaunchedAtLogin();
  const shouldStartWebUiServiceOnLaunch = isWebUIMode || (isBootAutoStart && startupSettings.openWebUiOnBoot);
  const shouldCreateMainWindow = !isWebUIMode && (!isBootAutoStart || !startupSettings.silentOnBoot);

  if (isResetPasswordMode) {
    // Handle password reset without creating window
    try {
      // Get username argument, filtering out flags (--xxx)
      // 获取用户名参数，过滤掉标志（--xxx）
      const resetPasswordIndex = process.argv.indexOf('--resetpass');
      const argsAfterCommand = process.argv.slice(resetPasswordIndex + 1);
      const username = argsAfterCommand.find((arg) => !arg.startsWith('--')) || 'admin';

      // Import resetpass logic
      const { resetPasswordCLI } = await import('./utils/resetPasswordCLI');
      await resetPasswordCLI(username);

      app.quit();
    } catch (error) {
      app.exit(1);
    }
  } else {
    // Tray is our primary entry point, especially for silent boot.
    ensureTray();

    if (shouldStartWebUiServiceOnLaunch) {
      const userConfigInfo = loadUserWebUIConfig();
      if (userConfigInfo.exists && userConfigInfo.path) {
        // Config file loaded from user directory
      }
      const resolvedPort = resolveWebUIPort(userConfigInfo.config);
      const allowRemote = resolveRemoteAccess(userConfigInfo.config);

      try {
        // Auto-start never opens browser. Manual --webui keeps old behavior.
        await startWebServer(resolvedPort, allowRemote, { openBrowser: isWebUIMode });
        webUiServiceStarted = true;
        webUiServiceInfo = { port: resolvedPort, allowRemote };
      } catch (error) {
        // Per product decision: do not block app launch on WebUI startup failure.
        console.warn('[AionUi] Failed to start WebUI service:', error);
      }
    }

    if (shouldCreateMainWindow) {
      createWindow();
    }

    if (isWebUIMode && isLinuxHeadless) {
      // In headless WebUI mode, keep the process alive.
    }
  }

  // 启动时初始化ACP检测器 (skip in --resetpass mode)
  if (!isResetPasswordMode) {
    await initializeAcpDetector();
  }
};

// Ensure we don't miss the ready event when running in CLI/WebUI mode
void app
  .whenReady()
  .then(handleAppReady)
  .catch((_error) => {
    // App initialization failed
    app.quit();
  });

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform === 'darwin') return;
  if (tray && getCloseToTray()) return;
  if (webUiServiceStarted) return;
  app.quit();
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (!isWebUIMode && app.isReady() && BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

app.on('before-quit', () => {
  isAppQuitting = true;
  // 在应用退出前清理工作进程
  WorkerManage.clear();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
